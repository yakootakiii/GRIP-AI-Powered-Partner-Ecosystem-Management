{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModalManager = void 0;\nexports.ariaHidden = ariaHidden;\nvar _ownerWindow = _interopRequireDefault(require(\"@mui/utils/ownerWindow\"));\nvar _ownerDocument = _interopRequireDefault(require(\"@mui/utils/ownerDocument\"));\nvar _getScrollbarSize = _interopRequireDefault(require(\"@mui/utils/getScrollbarSize\"));\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = (0, _ownerDocument.default)(container);\n  if (doc.body === container) {\n    return (0, _ownerWindow.default)(container).innerWidth > doc.documentElement.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\nfunction ariaHidden(element, hide) {\n  if (hide) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\nfunction getPaddingRight(element) {\n  return parseInt((0, _ownerWindow.default)(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\nfunction isAriaHiddenForbiddenOnElement(element) {\n  // The forbidden HTML tags are the ones from ARIA specification that\n  // can be children of body and can't have aria-hidden attribute.\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\n  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\n  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);\n  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\n  return isForbiddenTagName || isInputHidden;\n}\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  [].forEach.call(container.children, element => {\n    const isNotExcludedElement = !blacklist.includes(element);\n    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n    if (isNotExcludedElement && isNotForbiddenElement) {\n      ariaHidden(element, hide);\n    }\n  });\n}\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n    return false;\n  });\n  return idx;\n}\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = (0, _getScrollbarSize.default)((0, _ownerWindow.default)(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      });\n      // Use computed style, here to get the real padding to add our scrollbar width.\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;\n\n      // .mui-fixed is a global helper.\n      const fixedElements = (0, _ownerDocument.default)(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    }\n    let scrollContainer;\n    if (container.parentNode instanceof DocumentFragment) {\n      scrollContainer = (0, _ownerDocument.default)(container).body;\n    } else {\n      // Support html overflow-y: auto for scroll stability between pages\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n      const parent = container.parentElement;\n      const containerWindow = (0, _ownerWindow.default)(container);\n      scrollContainer = parent?.nodeName === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\n    }\n\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n  const restore = () => {\n    restoreStyle.forEach(({\n      value,\n      el,\n      property\n    }) => {\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n  return restore;\n}\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nclass ModalManager {\n  constructor() {\n    this.modals = [];\n    this.containers = [];\n  }\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n    modalIndex = this.modals.length;\n    this.modals.push(modal);\n\n    // If the modal we are adding is already in the DOM.\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));\n    const containerInfo = this.containers[containerIndex];\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n  remove(modal, ariaHiddenState = true) {\n    const modalIndex = this.modals.indexOf(modal);\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1);\n\n    // If that was the last modal in a container, clean up the container.\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, ariaHiddenState);\n      }\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\n      // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n    return modalIndex;\n  }\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n}\nexports.ModalManager = ModalManager;","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","ModalManager","ariaHidden","_ownerWindow","_ownerDocument","_getScrollbarSize","isOverflowing","container","doc","body","innerWidth","documentElement","clientWidth","scrollHeight","clientHeight","element","hide","setAttribute","removeAttribute","getPaddingRight","parseInt","getComputedStyle","paddingRight","isAriaHiddenForbiddenOnElement","forbiddenTagNames","isForbiddenTagName","includes","tagName","isInputHidden","getAttribute","ariaHiddenSiblings","mountElement","currentElement","elementsToExclude","blacklist","forEach","call","children","isNotExcludedElement","isNotForbiddenElement","findIndexOf","items","callback","idx","some","item","index","handleContainer","containerInfo","props","restoreStyle","disableScrollLock","scrollbarSize","push","style","property","el","fixedElements","querySelectorAll","scrollContainer","parentNode","DocumentFragment","parent","parentElement","containerWindow","nodeName","overflowY","overflow","overflowX","restore","setProperty","removeProperty","getHiddenSiblings","hiddenSiblings","constructor","modals","containers","add","modal","modalIndex","indexOf","length","modalRef","mount","containerIndex","remove","ariaHiddenState","splice","nextTop","isTopModal"],"sources":["/Users/ianemmanuelcomia/Documents/langchain/ui/node_modules/@mui/material/Modal/ModalManager.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModalManager = void 0;\nexports.ariaHidden = ariaHidden;\nvar _ownerWindow = _interopRequireDefault(require(\"@mui/utils/ownerWindow\"));\nvar _ownerDocument = _interopRequireDefault(require(\"@mui/utils/ownerDocument\"));\nvar _getScrollbarSize = _interopRequireDefault(require(\"@mui/utils/getScrollbarSize\"));\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = (0, _ownerDocument.default)(container);\n  if (doc.body === container) {\n    return (0, _ownerWindow.default)(container).innerWidth > doc.documentElement.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\nfunction ariaHidden(element, hide) {\n  if (hide) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\nfunction getPaddingRight(element) {\n  return parseInt((0, _ownerWindow.default)(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\nfunction isAriaHiddenForbiddenOnElement(element) {\n  // The forbidden HTML tags are the ones from ARIA specification that\n  // can be children of body and can't have aria-hidden attribute.\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\n  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\n  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);\n  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\n  return isForbiddenTagName || isInputHidden;\n}\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  [].forEach.call(container.children, element => {\n    const isNotExcludedElement = !blacklist.includes(element);\n    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n    if (isNotExcludedElement && isNotForbiddenElement) {\n      ariaHidden(element, hide);\n    }\n  });\n}\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n    return false;\n  });\n  return idx;\n}\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = (0, _getScrollbarSize.default)((0, _ownerWindow.default)(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      });\n      // Use computed style, here to get the real padding to add our scrollbar width.\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;\n\n      // .mui-fixed is a global helper.\n      const fixedElements = (0, _ownerDocument.default)(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    }\n    let scrollContainer;\n    if (container.parentNode instanceof DocumentFragment) {\n      scrollContainer = (0, _ownerDocument.default)(container).body;\n    } else {\n      // Support html overflow-y: auto for scroll stability between pages\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n      const parent = container.parentElement;\n      const containerWindow = (0, _ownerWindow.default)(container);\n      scrollContainer = parent?.nodeName === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\n    }\n\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n  const restore = () => {\n    restoreStyle.forEach(({\n      value,\n      el,\n      property\n    }) => {\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n  return restore;\n}\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nclass ModalManager {\n  constructor() {\n    this.modals = [];\n    this.containers = [];\n  }\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n    modalIndex = this.modals.length;\n    this.modals.push(modal);\n\n    // If the modal we are adding is already in the DOM.\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));\n    const containerInfo = this.containers[containerIndex];\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n  remove(modal, ariaHiddenState = true) {\n    const modalIndex = this.modals.indexOf(modal);\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1);\n\n    // If that was the last modal in a container, clean up the container.\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, ariaHiddenState);\n      }\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\n      // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n    return modalIndex;\n  }\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n}\nexports.ModalManager = ModalManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}